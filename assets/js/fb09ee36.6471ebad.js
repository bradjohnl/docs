"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[5300],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),i=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=i(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),u=i(n),h=r,f=u["".concat(l,".").concat(h)]||u[h]||p[h]||o;return n?a.createElement(f,s(s({ref:t},d),{},{components:n})):a.createElement(f,s({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,s[1]=c;for(var i=2;i<o;i++)s[i]=n[i];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},857:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return i},toc:function(){return d},default:function(){return u}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),s=["components"],c={},l="Calling Contracts",i={unversionedId:"dapp-dev-guide/calling-contracts",id:"dapp-dev-guide/calling-contracts",isDocsHomePage:!1,title:"Calling Contracts",description:"The most efficient way to use blockchain is to store (install) your contract on the system and then call it. This section outlines the steps to do this.",source:"@site/source/docs/casper/dapp-dev-guide/calling-contracts.md",sourceDirName:"dapp-dev-guide",slug:"/dapp-dev-guide/calling-contracts",permalink:"/docs/dapp-dev-guide/calling-contracts",editUrl:"https://github.com/casper-network/documentation/tree/master/docs/casper/dapp-dev-guide/calling-contracts.md",tags:[],version:"current",frontMatter:{},sidebar:"dapp-dev-guide",previous:{title:"Deploying Contracts",permalink:"/docs/dapp-dev-guide/deploying-contracts"},next:{title:"Execution Error Codes",permalink:"/docs/dapp-dev-guide/execution-error-codes"}},d=[{value:"Installing a Smart Contract",id:"installing-a-smart-contract",children:[]},{value:"Querying Global State for the Address of a Contract",id:"querying-global-state-for-the-address-of-a-contract",children:[{value:"Step 1: Get the Latest Global State Hash",id:"step-1-get-the-latest-global-state-hash",children:[]},{value:"Step 2: Query State",id:"step-2-query-state",children:[]},{value:"Example Result",id:"example-result",children:[]}]},{value:"Calling a Contract by Name &amp; Entry Point",id:"calling-a-contract-by-name--entry-point",children:[]},{value:"Calling a Contract by Hash and Entry Point",id:"calling-a-contract-by-hash-and-entry-point",children:[]}],p={toc:d};function u(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"calling-contracts"},"Calling Contracts"),(0,o.kt)("p",null,"The most efficient way to use blockchain is to store (install) your contract on the system and then call it. This section outlines the steps to do this."),(0,o.kt)("h2",{id:"installing-a-smart-contract"},"Installing a Smart Contract"),(0,o.kt)("p",null,"First, set up the contract name so you can call it using the name in subsequent deploys. The following code sample uses ",(0,o.kt)("inlineCode",{parentName:"p"},"sample_contract")," as the contract name."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let contract_hash = storage::add_contract_version(contract_package_hash,\n                                                  entry_points,\n                                                  Default::default());\nruntime::put_key("sample_contract", contract_hash.into());\n\nruntime::call_contract::<()>(contract_hash, "store_hello_world", {\n   let mut named_args = RuntimeArgs::new();\n   named_args.insert("s", s);\n   named_args.insert("a", a);\n   named_args\n});\n')),(0,o.kt)("p",null,"Next, deploy the smart contract using the ",(0,o.kt)("inlineCode",{parentName:"p"},"put-deploy")," command and send in the compiled wasm as ",(0,o.kt)("inlineCode",{parentName:"p"},"--session code"),"."),(0,o.kt)("h2",{id:"querying-global-state-for-the-address-of-a-contract"},"Querying Global State for the Address of a Contract"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"query-state")," command is a generic query against ",(0,o.kt)("a",{parentName:"p",href:"/docs/glossary/G#global-state"},"global state"),". Earlier, we queried global state for the account's main purse. Here, we query the state of a contract. We can do so by including the contract address rather than the account public key in the ",(0,o.kt)("inlineCode",{parentName:"p"},"query-state")," command."),(0,o.kt)("p",null,"Here we query to get the address of an ERC20 contract from Global State."),(0,o.kt)("h3",{id:"step-1-get-the-latest-global-state-hash"},"Step 1: Get the Latest Global State Hash"),(0,o.kt)("p",null,"We need to obtain the global state hash after our contract has been deployed to the network."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"casper-client get-state-root-hash --node-address http://NODE:PORT | jq -r\n")),(0,o.kt)("h3",{id:"step-2-query-state"},"Step 2: Query State"),(0,o.kt)("p",null,"Take the global state hash from Step 1 and include it here, along with the account public key that created the contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"casper-client query-state --node-address http://NODE:PORT -k <PUBLIC KEY IN  HEX> -s <STATE_ROOT_HASH>\n")),(0,o.kt)("h3",{id:"example-result"},"Example Result"),(0,o.kt)("p",null,"If there is a contract stored in an account, it will appear under ",(0,o.kt)("inlineCode",{parentName:"p"},"named-keys"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'casper-client query-state --node-address http://localhost:7777 -k 016af0262f67aa93a225d9d57451023416e62aaa8391be8e1c09b8adbdef9ac19d -s 0c3aaf547a55dd500c6c9bbd42bae45e97218f70a45fee6bf8ab04a89ccb9adb |jq -r\n{\n  "api_version": "1.0.0",\n  "stored_value": {\n    "Account": {\n      "account_hash": "804af75bc8161e1ec4189e7d4441eb1bf1047ff6fc13b1d71026f34c5f96f937",\n      "action_thresholds": {\n        "deployment": 1,\n        "key_management": 1\n      },\n      "associated_keys": [\n        {\n          "account_hash": "804af75bc8161e1ec4189e7d4441eb1bf1047ff6fc13b1d71026f34c5f96f937",\n          "weight": 1\n        }\n      ],\n      "main_purse": "uref-439d5326bf89bd34d3b2c924b3af2f5e233298b473d5bd8b54fab61ccef6c003-007",\n      "named_keys": {\n        "ERC20": "hash-d527103687bfe3188caf02f1e487bfb8f60bfc01068921f7db24db72a313cedb",\n        "ERC20_hash": "uref-80d9d36d628535f0bc45ae4d28b0228f9e07f250c3e85a85176dba3fc76371ce-007",\n\n      }\n    }\n  }\n}\n')),(0,o.kt)("h4",{id:"step-3-query-the-contract-state"},"Step 3: Query the contract State"),(0,o.kt)("p",null,"Now that we have the hash of the contract, we can query the contract's internal state. To do this, we pass in the contract's hash and the global state hash. If we look at the ERC20 contract, we see a token name specified as ",(0,o.kt)("inlineCode",{parentName:"p"},"_name"),". We can query for the value stored here."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"casper-client query-state --node-address http://localhost:7777 -k hash-d527103687bfe3188caf02f1e487bfb8f60bfc01068921f7db24db72a313cedb -s 0c3aaf547a55dd500c6c9bbd42bae45e97218f70a45fee6bf8ab04a89ccb9adb -q _name | jq -r\n")),(0,o.kt)("p",null,"And we should see something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'{\n  "api_version": "1.0.0",\n  "stored_value": {\n    "CLValue": {\n      "bytes": "0b000000e280984d65646861e28099",\n      "cl_type": "String"\n    }\n  }\n}\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": This result is returned as bytes. These bytes need to be deserialized into the correct CLType in a smart contract or a dApp. Refer to ",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/casper-types/latest/casper_types/bytesrepr/index.html"},"casper-types")," to find the latest APIs for deserialization."),(0,o.kt)("h2",{id:"calling-a-contract-by-name--entry-point"},"Calling a Contract by Name & Entry Point"),(0,o.kt)("p",null,"To call a contract by its name, run the ",(0,o.kt)("inlineCode",{parentName:"p"},"put-deploy")," command using the ",(0,o.kt)("inlineCode",{parentName:"p"},"session-name")," option:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"casper-client put-deploy --session-name <NAME> --session-entry-point <FUNCTION_NAME>\n")),(0,o.kt)("p",null,"It is possible to create entry points in the contract, which you can invoke while the contract lives on the blockchain. The following code shows you an example entry point:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\npub extern "C" fn store_u64() {\n   read_and_store::<u64>();\n}\n\nfn read_and_store<T: CLTyped + FromBytes + ToBytes>() {\n   let name: String = runtime::get_named_arg("name");\n   let value: T = runtime::get_named_arg("value");\n   set_key(name.as_str(), value);\n}\n')),(0,o.kt)("h2",{id:"calling-a-contract-by-hash-and-entry-point"},"Calling a Contract by Hash and Entry Point"),(0,o.kt)("p",null,"After deploying a contract and querying the global state, you can use a contract's hash to call it in a new deploy. An entry point is required when calling a contract by its hash."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"casper-client put-deploy  --session-hash <HEX STRING> --session-entry-point <FUNCTION_NAME>\n")))}u.isMDXComponent=!0}}]);