"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1450],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return h}});var s=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},i=Object.keys(e);for(s=0;s<i.length;s++)n=i[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(s=0;s<i.length;s++)n=i[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=s.createContext({}),c=function(e){var t=s.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},l=function(e){var t=c(e.components);return s.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},p=s.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=c(n),h=a,m=p["".concat(u,".").concat(h)]||p[h]||d[h]||i;return n?s.createElement(m,r(r({ref:t},l),{},{components:n})):s.createElement(m,r({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=p;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var c=2;c<i;c++)r[c]=n[c];return s.createElement.apply(null,r)}return s.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5014:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return u},default:function(){return h},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return d}});var s=n(3117),a=n(102),i=(n(7294),n(3905)),r=["components"],o={},u="Unit Testing Session Code",c={unversionedId:"dapp-dev-guide/writing-contracts/testing-session-code",id:"dapp-dev-guide/writing-contracts/testing-session-code",title:"Unit Testing Session Code",description:"This section describes how to test a session code based on the unit testing mechanism. It's recommended to follow the writing session code section before starting this tutorial. Here, we will cover how to test a successful session code execution and how to verify the success of the test program by asserting the return value.",source:"@site/source/docs/casper/dapp-dev-guide/writing-contracts/testing-session-code.md",sourceDirName:"dapp-dev-guide/writing-contracts",slug:"/dapp-dev-guide/writing-contracts/testing-session-code",permalink:"/dapp-dev-guide/writing-contracts/testing-session-code",editUrl:"https://github.com/casper-network/docs/tree/main/source/docs/casper/dapp-dev-guide/writing-contracts/testing-session-code.md",tags:[],version:"current",frontMatter:{},sidebar:"dapp-dev-guide",previous:{title:"Writing Session Code",permalink:"/dapp-dev-guide/writing-contracts/session-code"},next:{title:"Writing a Basic Smart Contract in Rust",permalink:"/dapp-dev-guide/writing-contracts/rust"}},l={},d=[{value:"Steps to Create and Run the Unit Test",id:"steps-to-create-and-run-the-unit-test",level:2},{value:"Step 1. Creating the test crate",id:"step-1-creating-the-test-crate",level:3},{value:"Step 2. Adding the project dependencies",id:"step-2-adding-the-project-dependencies",level:3},{value:"Step 3. Writing tests in the main.rs file",id:"step-3-writing-tests-in-the-mainrs-file",level:3},{value:"Step 4. Importing the required packages",id:"step-4-importing-the-required-packages",level:3},{value:"Step 5. Defining the constants",id:"step-5-defining-the-constants",level:3},{value:"Step 6. Creating the test function",id:"step-6-creating-the-test-function",level:3},{value:"Step 7. Verifying the test results",id:"step-7-verifying-the-test-results",level:3},{value:"Step 8. Running the test",id:"step-8-running-the-test",level:3},{value:"Video Walkthrough",id:"video-walkthrough",level:2},{value:"Other Code Samples",id:"other-code-samples",level:2},{value:"Sample contract used to build the session code",id:"sample-contract-used-to-build-the-session-code",level:4},{value:"Sample test code",id:"sample-test-code",level:4},{value:"What&#39;s Next?",id:"whats-next",level:2}],p={toc:d};function h(e){var t=e.components,n=(0,a.Z)(e,r);return(0,i.kt)("wrapper",(0,s.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"unit-testing-session-code"},"Unit Testing Session Code"),(0,i.kt)("p",null,"This section describes how to test a session code based on the unit testing mechanism. It's recommended to follow the ",(0,i.kt)("a",{parentName:"p",href:"/dapp-dev-guide/writing-contracts/session-code/"},"writing session code")," section before starting this tutorial. Here, we will cover how to test a successful session code execution and how to verify the success of the test program by asserting the return value."),(0,i.kt)("p",null,"The session code executes in the context of the account which sent the deploy. In this scenario, since the session code is executing in the corresponding account's contexts, it has the same access permissions as the corresponding account."),(0,i.kt)("p",null,"In this tutorial, we use the example from the ",(0,i.kt)("a",{parentName:"p",href:"#sample-contract-used-to-build-the-session-code"},"sample contract")," section to build the test program."),(0,i.kt)("h2",{id:"steps-to-create-and-run-the-unit-test"},"Steps to Create and Run the Unit Test"),(0,i.kt)("h3",{id:"step-1-creating-the-test-crate"},"Step 1. Creating the test crate"),(0,i.kt)("p",null,"Use the below command to create the test crate. It will auto-generate the folder structure for the test project."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo new tests\n")),(0,i.kt)("p",null,"This creates the ",(0,i.kt)("inlineCode",{parentName:"p"},"tests")," folder with the ",(0,i.kt)("inlineCode",{parentName:"p"},"/src/main.rs")," file and the ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo.toml")," file."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tests")," - This is the name you provide for the folder."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"main.rs")," - This is the file that contains the unit test code required to test the contract. You can rename the file if required."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Cargo.toml")," - This is the file with project configurations.")),(0,i.kt)("h3",{id:"step-2-adding-the-project-dependencies"},"Step 2. Adding the project dependencies"),(0,i.kt)("p",null,"Include the below dependencies inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'[dev-dependencies]\ncasper-execution-engine = "1.5.0"\ncasper-engine-test-support = {version = "2.1.0", features = ["test-support"]}\ncasper-types = "1.5.0"\n')),(0,i.kt)("p",null,"Importing the dependencies may vary with your project requirements. These are the basic dependencies required by this project."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"casper-execution-engine")," - This imports the functionalities of the execution engine which enables the Wasm execution. Each node contains an instance of an execution engine within it."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"casper-engine-test-support")," - This is a helper crate that provides the interface to interact with the execution engine to execute the Wasm."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"casper-types")," - These are Casper's custom types used in the program.")),(0,i.kt)("h3",{id:"step-3-writing-tests-in-the-mainrs-file"},"Step 3. Writing tests in the main.rs file"),(0,i.kt)("p",null,"You can include the ",(0,i.kt)("inlineCode",{parentName:"p"},"#![no_main]")," annotation or include an empty main method to initialze the test program."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n panic!("Execute \\"cargo test\\" to test the contract, not \\"cargo run\\".");\n}\n')),(0,i.kt)("p",null,"Adjust the file attributes to support the execution environment. The ",(0,i.kt)("inlineCode",{parentName:"p"},"#[cfg(test)]")," attribute tells the Rust compiler to compile and run the test code only when invoking ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo test"),", not when debugging or releasing. All your individual testing functions go within ",(0,i.kt)("inlineCode",{parentName:"p"},"mod tests")," which indicates the grouping mechanism."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(test)]\nmod tests {\n    The whole test program resides here...\n}\n")),(0,i.kt)("h3",{id:"step-4-importing-the-required-packages"},"Step 4. Importing the required packages"),(0,i.kt)("p",null,"The subsequent code modules use these packages to prepare and send the session code to the network."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use std::path::PathBuf;\nuse casper_engine_test_support::{DeployItemBuilder,\nExecuteRequestBuilder, InMemoryWasmTestBuilder,\nDEFAULT_RUN_GENESIS_REQUEST, DEFAULT_ACCOUNT_ADDR,\nDEFAULT_PAYMENT, ARG_AMOUNT};\nuse casper_execution_engine::core::engine_state::{\n        run_genesis_request::RunGenesisRequest, GenesisAccount,\n    };\nuse casper_types::{\n        account::AccountHash, runtime_args, Key, Motes,\n        PublicKey, RuntimeArgs, SecretKey, U512,\n    };\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PathBuf")," - This package supports loading the session code Wasm."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"casper_engine_test_support")," - This package provides the interfaces to write tests and interact with an instance of the execution engine."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"casper_execution_engine")," - This package imports the Casper execution engine itself."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"casper_types")," - These packages enable the general type imports to the test program.")),(0,i.kt)("h3",{id:"step-5-defining-the-constants"},"Step 5. Defining the constants"),(0,i.kt)("p",null,"The names of the runtime arguments are defined as constants. It is mandatory to use the exact names as in the original contract class to define these constants. These are dictated by the arguments specified by the session code. If your session code takes in different arguments, you should define them as constants at this point."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'const ARG_NUMBER_1: &str = "number_1";\nconst ARG_NUMBER_2: &str = "number_2";\n// This constant defines which wasm file to load and pass to the instance of the EE\nconst CONTRACT_WASM: &str = "contract.wasm";\n')),(0,i.kt)("h3",{id:"step-6-creating-the-test-function"},"Step 6. Creating the test function"),(0,i.kt)("p",null,"In this step, you will build the program to test the contract."),(0,i.kt)("p",null,"Start with annotating the function with ",(0,i.kt)("inlineCode",{parentName:"p"},"#[test]")," attribute. This indicates the function as a test function and performs the execution accordingly. The bodies of test functions typically perform some setup, run the code we want to test, then assert whether the results are what we expect."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[test]\nfn <your-unit-test-name>{\n   Individual test function implementation...\n}\n")),(0,i.kt)("p",null,"Following is a code sample of a basic unit test for adding two numbers. ",(0,i.kt)("inlineCode",{parentName:"p"},"should_add_two_numbers")," is the name given to this specific unit test."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'fn should_add_two_numbers() {\n\n// Initialize an instance of the execution engine and assign it to the builder variable\nlet mut builder = InMemoryWasmTestBuilder::default();\n\n// Execute the genesis process\nbuilder.run_genesis(&*DEFAULT_RUN_GENESIS_REQUEST).commit();\n\n// Retrieve the contract wasm from the specified location and assign to the session code variable\nlet session_code = PathBuf::from(CONTRACT_WASM);\n\n// Retrieve runtime arguments. These should be same as defined in the contract\n// This allows use to check and assert behavior of the session code\nlet runtime_args = runtime_args! {\n    ARG_NUMBER_1 => 1,\n    ARG_NUMBER_2 => 2\n};\n\n// Create a deploy item, which emulates the deploy being sent to the network\n// Use the host side functionality of standard payment and passes in the required runtime argument "amount" with some default value\n// Load the session wasm and pass in the runtime arguments\n// Sets up the session code to be executed in the default account using auth keys and default account address\nlet deploy_item = DeployItemBuilder::new()\n    .with_empty_payment_bytes(runtime_args! {\n                ARG_AMOUNT => *DEFAULT_PAYMENT})\n    .with_session_code(CONTRACT_WASM, runtime_args.clone())\n    .with_authorization_keys(&[*DEFAULT_ACCOUNT_ADDR])\n    .with_address(*DEFAULT_ACCOUNT_ADDR)\n    .build();\n\n// Create the execution request that will eventually be executed by the EE.\nlet execute_request = ExecuteRequestBuilder::from_deploy_item(\n            deploy_item\n    ).build();\n\n// Invoke the EE to execute the session code that we are testing\nbuilder.exec(execute_request).expect_success()\n            .commit();\n\n// Verify the results of the execution match our expectations from the contract using the test results\nlet result_key = *builder\n            .get_account(*DEFAULT_ACCOUNT_ADDR)\n            .expect("the default account must be present")\n            .named_keys()\n            .get("answer")\n            .expect("must have key as part of session code execution");\nlet value: u32 = builder.query(None, result_key, &vec![])\n            .expect("must have the stored value")\n            .as_cl_value()\n            .expect("must have some CLValue")\n            .to_owned()\n            .into_t()\n            .expect("must convert the CLValue into a u64");\nassert_eq!(3, value);\n    }\n}\n')),(0,i.kt)("p",null,"The above code snippet starts by initializing the test builder and the genesis request. Then, the contract Wasm is loaded to the session code object. After that, the deploy object is created using the details like payment method, contract Wasm, and account address. Then, the deploy object is passed to the created execute request. Finally, the execution engine is invoked to process the execute request. Refer to ",(0,i.kt)("a",{parentName:"p",href:"/dapp-dev-guide/writing-contracts/testing/#deploy-the-smart-contract"},"creating a test function")," for more details about each function."),(0,i.kt)("h3",{id:"step-7-verifying-the-test-results"},"Step 7. Verifying the test results"),(0,i.kt)("p",null,"In the above section, the session code is sent to the network. Now it's time to verify the results of that deployment. Once the session code has been executed successfully, we must verify that the results of the execution match our expectations."),(0,i.kt)("p",null,"The below code snippet retrieves the value of interest which is named as ",(0,i.kt)("inlineCode",{parentName:"p"},"answer"),". It is stored under the URef which is a part of the account's named keys. Then, the formatted value is asserted against our expected value to verify the success of the test program."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let result_key = *builder\n            .get_account(*DEFAULT_ACCOUNT_ADDR)\n            .expect("the default account must be present")\n            .named_keys()\n            .get("answer")\n            .expect("must have key as part of session code execution");\n')),(0,i.kt)("p",null,"The next part reads the ",(0,i.kt)("inlineCode",{parentName:"p"},"result_key")," by calling the query method and assign the result of it to the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"result_key")," needs to trnsform in order to match with the data type we are trying to assert with."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let value: u32 = builder.query(None, result_key, &vec![])\n            .expect("must have the stored value")\n            .as_cl_value()\n            .expect("must have some CLValue")\n            .to_owned()\n            .into_t()\n            .expect("must convert the CLValue into a u64");\n')),(0,i.kt)("p",null,"Finally, assert that the query's result matches the expected value; here, the expected value is 3."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"assert_eq!(3, value);\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"query()")," : Queries the state for a given value"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expect()")," : Validates the query which contains the output message. This will unwrap the value; the test will panic and crash if the value can't be unwrapped. The string value inside the argument will output as the reason to crash"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"as_cl_value()")," : Returns a wrapped ",(0,i.kt)("a",{parentName:"li",href:"design/serialization-standard#serialization-standard-values"},"CLValue")," if this is a CLValue variant"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Into_t()")," : Converts the CLValue back to the original type (i.e., a String type in this sample). Note that the ",(0,i.kt)("inlineCode",{parentName:"li"},"expected_value")," is a ",(0,i.kt)("inlineCode",{parentName:"li"},"String")," type lifted to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Value")," type. It is also possible to map ",(0,i.kt)("inlineCode",{parentName:"li"},"returned_value")," to the ",(0,i.kt)("inlineCode",{parentName:"li"},"String")," type")),(0,i.kt)("h3",{id:"step-8-running-the-test"},"Step 8. Running the test"),(0,i.kt)("p",null,"Use the below command to run the test."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"make test\n")),(0,i.kt)("p",null,"This command should be configured inside the project's ",(0,i.kt)("inlineCode",{parentName:"p"},"Makefile"),". It generates the ",(0,i.kt)("inlineCode",{parentName:"p"},"tests/wasm")," folder and runs the tests."),(0,i.kt)("p",null,"Below is a section of the make file that contains a set of configurations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"prepare:\n    rustup target add wasm32-unknown-unknown\n\nbuild-contract:\n    cd contract && cargo build --release -p contract --target wasm32-unknown-unknown\n    wasm-strip contract/target/wasm32-unknown-unknown/release/contract.wasm 2>/dev/null | true\n\ntest: build-contract\n    mkdir -p tests/wasm\n    cp contract/target/wasm32-unknown-unknown/release/contract.wasm tests/wasm\n    cd tests && cargo test\n")),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Use the command ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo install cargo casper"),", if you want to set up the whole directory structure in one command. Refer to ",(0,i.kt)("a",{parentName:"p",href:"/dapp-dev-guide/writing-contracts/getting-started/#installing-the-casper-crates"},"installing casper crates")," section for more details."))),(0,i.kt)("h2",{id:"video-walkthrough"},"Video Walkthrough"),(0,i.kt)("p",null,"The following brief video describes testing the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/two-party-multi-sig/"},"sample session code")," for configuring an account."),(0,i.kt)("p",{align:"center"},(0,i.kt)("iframe",{width:"400",height:"225",src:"https://www.youtube.com/embed?v=sUg0nh3K3iQ&list=PL8oWxbJ-csEqi5FP87EJZViE2aLz6X1Mj&index=5",frameborder:"0",allow:"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),(0,i.kt)("h2",{id:"other-code-samples"},"Other Code Samples"),(0,i.kt)("p",null,"Expand the sections below to view the complete code samples and unit tests."),(0,i.kt)("h4",{id:"sample-contract-used-to-build-the-session-code"},"Sample contract used to build the session code"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Contract code sample used in the session code testing"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#![no_std]\n#![no_main]\nuse casper_contract::contract_api::{runtime, storage};\nconst ARG_NUMBER_1: &str = "number_1";\nconst ARG_NUMBER_2: &str = "number_2";\n#[no_mangle]\npub extern "C" fn call() {\n    // Get the named arg number_1\n    let num1: u32 = runtime::get_named_arg(ARG_NUMBER_1);\n    // Get the named_arg number_2\n    let num2: u32 = runtime::get_named_arg(ARG_NUMBER_2);\n    let result = num1 + num2;\n    // Write the answer under some URef\n    let result_uref = storage::new_uref(result);\n    // Put the URef in the current context, which is the context of the account calling this piece of session code.\n    runtime::put_key("answer", result_uref.into())\n}\n'))),(0,i.kt)("h4",{id:"sample-test-code"},"Sample test code"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Unit test code sample to test the session code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg(test)]\nmod tests {\n\nuse std::path::PathBuf;\nuse casper_engine_test_support::{DeployItemBuilder, ExecuteRequestBuilder, InMemoryWasmTestBuilder, DEFAULT_RUN_GENESIS_REQUEST, DEFAULT_ACCOUNT_ADDR, DEFAULT_PAYMENT, ARG_AMOUNT};\nuse casper_execution_engine::core::engine_state::{\n        run_genesis_request::RunGenesisRequest, GenesisAccount,\n    };\nuse casper_types::{\n        account::AccountHash, runtime_args, Key, Motes, PublicKey, RuntimeArgs, SecretKey, U512,\n    };\n\nconst ARG_NUMBER_1: &str = "number_1";\nconst ARG_NUMBER_2: &str = "number_2";\nconst CONTRACT_WASM: &str = "contract.wasm";\n\n#[test]\n    fn should_add_two_numbers() {\n\n    let mut builder = InMemoryWasmTestBuilder::default();\n\n    builder.run_genesis(&*DEFAULT_RUN_GENESIS_REQUEST).commit();\n\n    let session_code = PathBuf::from(CONTRACT_WASM);\n\n    let runtime_args = runtime_args! {\n        ARG_NUMBER_1 => 1,\n        ARG_NUMBER_2 => 2\n    };\n\n    let deploy_item = DeployItemBuilder::new()\n    .with_empty_payment_bytes(runtime_args! {\n    ARG_AMOUNT => *DEFAULT_PAYMENT\n    })\n    .with_session_code(CONTRACT_WASM, runtime_args.clone())\n    .with_authorization_keys(&[*DEFAULT_ACCOUNT_ADDR])\n    .with_address(*DEFAULT_ACCOUNT_ADDR)\n    .build();\n\n    let execute_request = ExecuteRequestBuilder::from_deploy_item(\n        deploy_item\n        ).build();\n\n    let _example_request = ExecuteRequestBuilder::standard(\n        *DEFAULT_ACCOUNT_ADDR,\n        CONTRACT_WASM,\n        runtime_args\n        ).build();\n        .\n        builder.exec(execute_request).expect_success()\n            .commit();\n\n    let result_key = *builder\n        .get_account(*DEFAULT_ACCOUNT_ADDR)\n        .expect("the default account must be present")\n        .named_keys()\n        .get("answer")\n        .expect("must have key as part of session code execution");\n    let value: u32 = builder.query(None, result_key, &vec![])\n        .expect("must have the stored value")\n        .as_cl_value()\n        .expect("must have some CLValue")\n        .to_owned()\n        .into_t()\n        .expect("must convert the CLValue into a u64");\nassert_eq!(3, value);\n    }\n}\n\n fn main() {\n    panic!("Execute \\"cargo test\\" to test the contract, not \\"cargo run\\".");\n }\n}\n'))),(0,i.kt)("h2",{id:"whats-next"},"What's Next?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Learn to ",(0,i.kt)("a",{parentName:"li",href:"/dapp-dev-guide/writing-contracts/rust"},"write a smart contract in Rust"))))}h.isMDXComponent=!0}}]);